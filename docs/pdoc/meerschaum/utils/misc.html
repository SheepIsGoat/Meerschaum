<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>meerschaum.utils.misc API documentation</title>
<meta name="description" content="Miscellaneous functions go here" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>meerschaum.utils.misc</code></h1>
</header>
<section id="section-intro">
<p>Miscellaneous functions go here</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
&#34;&#34;&#34;
Miscellaneous functions go here
&#34;&#34;&#34;

from __future__ import annotations
from meerschaum.utils.typing import Union, Mapping, Any, Callable, Optional, ClassVar

import sys

def add_method_to_class(
        func : Callable[[Any], Any],
        class_def : ClassVar[dict[Any, Any]],
        method_name : Optional[str] = None
    ) -&gt; Callable[[Any], Any]:
    &#34;&#34;&#34;
    Add function `func` to class `class_def`.

    :param func:
        Function to be added as a method of the class

    :param class_def:
        Class we are modifying

    :param method_name:
        New name of the method. None will use func.__name__ (default).
    &#34;&#34;&#34;
    from functools import wraps

    @wraps(func)
    def wrapper(self, *args, **kw):
        return func(*args, **kw)

    if method_name is None: method_name = func.__name__
    setattr(class_def, method_name, wrapper)
    return func

def choose_subaction(
        action : list = [&#39;&#39;],
        options : dict = {},
        **kw
    ) -&gt; tuple:
    &#34;&#34;&#34;
    Given a dictionary of options and the standard Meerschaum actions list,
    check if choice is valid and execute chosen function, else show available
    options and return False

    action - list:
        subactions (e.g. `show pipes` -&gt; [&#39;pipes&#39;])
    options - dict:
        Available options to execute
        option (key) -&gt; function (value)
        Functions must accept **kw keyword arguments
        and return a tuple of success code and message
    &#34;&#34;&#34;
    from meerschaum.utils.warnings import warn, info
    import inspect
    parent_action = inspect.stack()[1][3]
    if len(action) == 0: action = [&#39;&#39;]
    choice = action[0]

    def valid_choice(_choice : str, _options : dict):
        if _choice in _options: return _choice
        if (_choice + &#39;s&#39;) in options: return _choice + &#39;s&#39;
        return None

    parsed_choice = valid_choice(choice, options)
    if parsed_choice is None:
        warn(f&#34;Cannot {parent_action} &#39;{choice}&#39;. Choose one:&#34;, stack=False)
        for option in sorted(options):
            print(f&#34;  - {parent_action} {option}&#34;)
        return (False, f&#34;Invalid choice &#39;{choice}&#39;&#34;)
    ### remove parent sub-action
    kw[&#39;action&#39;] = list(action)
    del kw[&#39;action&#39;][0]
    return options[parsed_choice](**kw)

def generate_password(
        length : int = 12
    ):
    &#34;&#34;&#34;
    Generate a secure password of given length.
    &#34;&#34;&#34;
    import secrets, string
    return &#39;&#39;.join((secrets.choice(string.ascii_letters) for i in range(length)))

def is_int(s):
    &#34;&#34;&#34;
    Check if string is an int
    &#34;&#34;&#34;
    try:
        float(s)
    except ValueError:
        return False
    else:
        return float(s).is_integer()

def get_options_functions():
    &#34;&#34;&#34;
    Get options functions from parent module
    &#34;&#34;&#34;
    import inspect
    parent_globals = inspect.stack()[1][0].f_globals
    parent_package = parent_globals[&#39;__name__&#39;]
    print(parent_package)

def string_to_dict(
        params_string : str
    ) -&gt; dict:
    &#34;&#34;&#34;
    Parse a string into a dictionary

    If the string begins with &#39;{&#39;, parse as JSON. Else use simple parsing

    &#34;&#34;&#34;
    if params_string == &#34;&#34;: return dict()

    if str(params_string)[0] == &#39;{&#39;:
        import json
        return json.loads(params_string)

    import ast
    params_dict = dict()
    for param in params_string.split(&#34;,&#34;):
        values = param.split(&#34;:&#34;)
        try:
            key = ast.literal_eval(values[0])
        except:
            key = str(values[0])

        for value in values[1:]:
            try:
                params_dict[key] = ast.literal_eval(value)
            except:
                params_dict[key] = str(value)
    return params_dict

def parse_config_substitution(
        value : str,
        leading_key : str = &#39;MRSM&#39;,
        begin_key : str = &#39;{&#39;,
        end_key : str = &#39;}&#39;,
        delimeter : str = &#39;:&#39;
    ):
    &#34;&#34;&#34;
    Parse Meerschaum substitution syntax
    E.g. MRSM{value1:value2} =&gt; [&#39;value1&#39;, &#39;value2&#39;]
    NOTE: Not currently used. See `search_and_substitute_config` below
    &#34;&#34;&#34;
    if not value.beginswith(leading_key):
        return value

    return leading_key[len(leading_key):][len():-1].split(delimeter)

def search_and_substitute_config(
        config : dict,
        leading_key : str = &#34;MRSM&#34;,
        delimiter : str = &#34;:&#34;,
        begin_key : str = &#34;{&#34;,
        end_key : str = &#34;}&#34;
    ) -&gt; dict:
    &#34;&#34;&#34;
    Search the config for Meerschaum substitution syntax and substite with value of keys

    Example:
        MRSM{meerschaum:connectors:main:host} =&gt; cf[&#39;meerschaum&#39;][&#39;connectors&#39;][&#39;main&#39;][&#39;host&#39;]
    &#34;&#34;&#34;
    try:
        import yaml
    except ImportError:
        return config
    needle = leading_key
    haystack = yaml.dump(config)
    mod_haystack = list(str(haystack))
    buff = str(needle)
    max_index = len(haystack) - len(buff)

    patterns = dict()

    begin, end, floor = 0, 0, 0
    while needle in haystack[floor:]:
        ### extract the keys
        hs = haystack[floor:]

        ### the first character of the keys
        ### MRSM{value1:value2}
        ###      ^
        begin = hs.find(needle) + len(needle) + len(begin_key)

        ### number of characters to end of keys
        ### (really it&#39;s the index of the beginning of the end_key relative to the beginning
        ###     but the math works out)
        ### MRSM{value1}
        ###      ^     ^  =&gt; 6
        length = hs[begin:].find(end_key)

        ### index of the end_key (end of `length` characters)
        end = begin + length

        ### advance the floor to find the next leading key
        floor += end + len(end_key)
        keys = hs[begin:end].split(delimiter)

        ### follow the pointers to the value
        c = config
        for k in keys:
            try:
                c = c[k]
            except KeyError:
                from meerschaum.utils.warnings import warn
                warn(f&#34;Invalid keys in config: {keys}&#34;)
        value = c

        ### pattern to search and replace
        pattern = leading_key + begin_key + delimiter.join(keys) + end_key
        ### store patterns and values
        patterns[pattern] = value

    ### replace the patterns with the values
    for pattern, value in patterns.items():
        haystack = haystack.replace(pattern, str(value))

    ### parse back into dict
    return yaml.safe_load(haystack)

def edit_file(
        path : &#39;pathlib.Path&#39;,
        default_editor : str = &#39;pyvim&#39;,
        debug : bool = False
    ):
    &#34;&#34;&#34;
    Open a file for editing. Attempts to use the user&#39;s defined EDITOR,
    otherwise uses pyvim.
    &#34;&#34;&#34;
    import os
    from subprocess import call
    from meerschaum.utils.debug import dprint
    from meerschaum.utils.packages import run_python_package
    try:
        EDITOR = os.environ.get(&#39;EDITOR&#39;, default_editor)
        if debug: dprint(f&#34;Opening file &#39;{path}&#39; with editor &#39;{EDITOR}&#39;&#34;)
        call([EDITOR, path])
    except Exception as e: ### can&#39;t open with default editors
        if debug: dprint(e)
        if debug: dprint(&#39;Failed to open file with system editor. Falling back to pyvim...&#39;)
        run_python_package(&#39;pyvim&#39;, [path], debug=debug)

def is_pipe_registered(
        pipe : &#39;Pipe or MetaPipe&#39;,
        pipes : dict,
        debug : bool = False
    ):
    &#34;&#34;&#34;
    Check if a Pipe or MetaPipe is inside the pipes dictionary.
    &#34;&#34;&#34;
    from meerschaum.utils.debug import dprint
    ck, mk, lk = pipe.connector_keys, pipe.metric_key, pipe.location_key
    if debug:
        dprint(f&#39;{ck}, {mk}, {lk}&#39;)
        dprint(f&#39;{pipe}, {pipes}&#39;)
    return ck in pipes and mk in pipes[ck] and lk in pipes[ck][mk]

def get_subactions(action : str, globs : dict = None) -&gt; list:
    &#34;&#34;&#34;
    Return a list of function pointers to all subactions for a given action
    &#34;&#34;&#34;
    if globs is None:
        import importlib
        module = importlib.import_module(f&#39;meerschaum.actions.{action}&#39;)
        globs = vars(module)
    subactions = []
    for item in globs:
        if f&#39;_{action}&#39; in item:
            subactions.append(globs[item])
    return subactions

def choices_docstring(action : str, globs : dict = None):
    options_str = f&#34;\n    Options:\n        `{action} &#34;
    subactions = get_subactions(action, globs=globs)
    options_str += &#34;[&#34;
    sa_names = []
    for sa in subactions:
        sa_names.append(sa.__name__[len(f&#34;_{action}&#34;) + 1:])
    for sa_name in sorted(sa_names):
        options_str += f&#34;{sa_name}, &#34;
    options_str = options_str[:-2] + &#34;]`&#34;
    return options_str

def print_options(
        options : dict = {},
        nopretty : bool = False,
        name : str = &#39;options&#39;,
        header : str = None,
        **kw
    ) -&gt; None:
    &#34;&#34;&#34;
    Show available options from an iterable
    &#34;&#34;&#34;
    from meerschaum.utils.formatting import make_header
    _options = []
    for o in options: _options.append(str(o))

    print()
    if not nopretty:
        if header is None: _header = f&#34;Available {name}:&#34;
        else: _header = header
        print(make_header(_header))
        ### calculate underline length
        #  underline_len = len(_header)
        #  for o in _options:
            #  if len(str(o)) + 4 &gt; underline_len:
                #  underline_len = len(str(o)) + 4
        #  ### print underline
        #  for i in range(underline_len): print(&#39;-&#39;, end=&#34;&#34;)
        #  print(&#34;\n&#34;, end=&#34;&#34;)
    ### print actions
    for option in sorted(_options):
        if not nopretty: print(&#34;  - &#34;, end=&#34;&#34;)
        print(option)

    print()

def sorted_dict(d : dict) -&gt; dict:
    &#34;&#34;&#34;
    Sort a dictionary&#39;s keys and values and return a new dictionary
    &#34;&#34;&#34;
    try:
        return {key: value for key, value in sorted(d.items(), key=lambda item: item[1])}
    except:
        return d

def flatten_pipes_dict(pipes_dict : dict) -&gt; list:
    &#34;&#34;&#34;
    Convert the standard pipes dictionary into a list
    &#34;&#34;&#34;
    pipes_list = []
    for ck in pipes_dict.values():
        for mk in ck.values():
            pipes_list += list(mk.values())
    return pipes_list

def round_time(
        dt : &#39;datetime.datetime&#39; = None,
        date_delta : &#39;datetime.timedelta&#39; = None,
        to : &#39;str&#39; = &#39;down&#39;
    ) -&gt; &#39;datetime.datetime&#39;:
    &#34;&#34;&#34;
    Round a datetime object to a multiple of a timedelta
    dt : datetime.datetime object, default now.
    dateDelta : timedelta object, we round to a multiple of this, default 1 minute.
    from:  http://stackoverflow.com/questions/3463930/how-to-round-the-minute-of-a-datetime-object-python
    &#34;&#34;&#34;
    import datetime
    if date_delta is None: date_delta = datetime.timedelta(minutes=1)
    round_to = date_delta.total_seconds()
    if dt is None:
        dt = datetime.datetime.utcnow()
    seconds = (dt.replace(tzinfo=None) - dt.min.replace(tzinfo=None)).seconds

    if seconds % round_to == 0 and dt.microsecond == 0:
        rounding = (seconds + round_to / 2) // round_to * round_to
    else:
        if to == &#39;up&#39;:
            # // is a floor division, not a comment on following line (like in javascript):
            rounding = (seconds + dt.microsecond/1000000 + round_to) // round_to * round_to
        elif to == &#39;down&#39;:
            rounding = seconds // round_to * round_to
        else:
            rounding = (seconds + round_to / 2) // round_to * round_to

    return dt + datetime.timedelta(0, rounding - seconds, - dt.microsecond)

def parse_df_datetimes(
        df : &#39;pd.DataFrame&#39;,
        debug : bool = False
    ) -&gt; &#39;pd.DataFrame&#39;:
    &#34;&#34;&#34;
    Parse a pandas DataFrame for datetime columns and cast as datetimes
    &#34;&#34;&#34;
    from meerschaum.utils.packages import import_pandas
    ### import pandas (or pandas replacement)
    from meerschaum.utils.debug import dprint
    pd = import_pandas()

    ### if df is a dict, build DataFrame
    if not isinstance(df, pd.DataFrame):
        if debug: dprint(f&#34;df is not a DataFrame. Casting to DataFrame...&#34;)
        df = pd.DataFrame(df)

    ### skip parsing if DataFrame is empty
    if len(df) == 0:
        if debug: dprint(f&#34;df is empty. Returning original DataFrame without casting datetime columns...&#34;)
        return df

    ### apply regex to columns to determine which are ISO datetimes
    iso_dt_regex = r&#39;\d{4}-\d{2}-\d{2}.\d{2}\:\d{2}\:\d{2}&#39;
    dt_mask = df.astype(str).apply(
        lambda s : s.str.match(iso_dt_regex).all()
    )

    ### list of datetime column names
    datetimes = list(df.loc[:, dt_mask])
    if debug: dprint(&#34;Converting columns to datetimes: &#34; + str(datetimes))

    ### apply to_datetime
    df[datetimes] = df[datetimes].apply(pd.to_datetime)

    ### strip timezone information
    for dt in datetimes:
        df[dt] = df[dt].dt.tz_localize(None)

    return df

async def retry_connect(
        connector : Union[meerschaum.connectors.sql.SQLConnector, databases.Database, None] = None,
        max_retries : int = 40,
        retry_wait : int = 3,
        debug : bool = False,
    ):
    &#34;&#34;&#34;
    Keep trying to connect to the database.
    Use wait_for_connection for non-async
    &#34;&#34;&#34;
    from meerschaum.utils.warnings import warn
    from meerschaum.utils.debug import dprint
    from meerschaum import get_connector
    from meerschaum.connectors.sql import SQLConnector
    import time

    ### get default connector if None is provided
    if connector is None:
        connector = get_connector()

    database = connector
    if isinstance(connector, SQLConnector):
        database = connector.db


    retries = 0
    while retries &lt; max_retries:
        if debug:
            dprint(f&#34;Trying to connect to the database&#34;)
            dprint(f&#34;Attempt ({retries + 1} / {max_retries})&#34;)
        try:
            await database.connect()

        except Exception as e:
            dprint(f&#34;Connection failed. Retrying in {retry_wait} seconds...&#34;)
            time.sleep(retry_wait)
            retries += 1
        else:
            if debug: dprint(&#34;Connection established!&#34;)
            break

def wait_for_connection(**kw):
    &#34;&#34;&#34;
    Block until a connection to the SQL database is made.
    &#34;&#34;&#34;
    import asyncio
    asyncio.run(retry_connect(**kw))

def sql_item_name(s : str, flavor : str) -&gt; str:
    &#34;&#34;&#34;
    Parse SQL items depending on the flavor
    &#34;&#34;&#34;
    if flavor in {&#39;timescaledb&#39;, &#39;postgresql&#39;}: s = pg_capital(s)
    elif flavor == &#39;sqlite&#39;: s = &#34;\&#34;&#34; + s + &#34;\&#34;&#34;
    return s

def pg_capital(s : str) -&gt; str:
    &#34;&#34;&#34;
    If string contains a capital letter, wrap it in double quotes

    returns: string
    &#34;&#34;&#34;
    if &#39;&#34;&#39; in s: return s
    needs_quotes = False
    for c in str(s):
        if c.isupper():
            needs_quotes = True
            break
    if needs_quotes:
        return &#39;&#34;&#39; + s + &#39;&#34;&#39;
    return s

def df_from_literal(
        pipe : &#39;meerschaum.Pipe&#39; = None,
        literal : str = None,
        debug : bool = False
    ) -&gt; &#39;pd.DataFrame&#39;:
    &#34;&#34;&#34;
    Parse a literal (if nessary), and use a Pipe&#39;s column names to generate a DataFrame.
    &#34;&#34;&#34;
    from meerschaum.utils.packages import import_pandas
    from meerschaum.utils.warnings import error, warn
    from meerschaum.utils.debug import dprint

    if pipe is None or literal is None:
        error(&#34;Please provide a Pipe and a literal value&#34;)
    ### this will raise an error if the columns are undefined
    dt_name, val_name = pipe.get_columns(&#39;datetime&#39;, &#39;value&#39;)

    val = literal
    if isinstance(literal, str):
        if debug: dprint(f&#34;Received literal string: &#39;{literal}&#39;&#34;)
        import ast
        try:
            val = ast.literal_eval(literal)
        except:
            warn(
                &#34;Failed to parse value from string:\n&#34; + f&#34;{literal}&#34; +
                &#34;\n\nWill cast as a string instead.&#34;\
            )
            val = literal

    ### NOTE: we do everything in UTC if possible.
    ### In dealing with timezones / Daylight Savings lies madness.
    import datetime
    now = datetime.datetime.utcnow()

    pd = import_pandas()
    return pd.DataFrame({dt_name : [now], val_name : [val]})

def filter_unseen_df(
        old_df : &#39;pd.DataFrame&#39;,
        new_df : &#39;pd.DataFrame&#39;,
        dtypes : dict = None,
        custom_nan : str = &#39;mrsm_NaN&#39;,
        debug : bool = False,
    ) -&gt; &#39;pd.DataFrame&#39;:
    &#34;&#34;&#34;
    Left join two DataFrames to find the newest unseen data.

    I have scoured the web for the best way to do this.
    My intuition was to join on datetime and id, but the code below accounts for values as well
    without needing to define expicit columns or indices.

    The logic below is based off this StackOverflow question, with an index reset thrown on top:
    https://stackoverflow.com/questions/48647534/python-pandas-find-difference-between-two-data-frames#48647840

    Also, NaN apparently does not equal NaN, so I am temporarily replacing instances of NaN with a
    custom string, per this StackOverflow question:
    https://stackoverflow.com/questions/31833635/pandas-checking-for-nan-not-working-using-isin

    Lastly, use the old DataFrame&#39;s columns for the new DataFrame, because order matters when checking equality.
    &#34;&#34;&#34;
    if old_df is None: return new_df
    old_cols = list(old_df.columns)
    try:
        new_df = new_df[old_cols]
    except Exception as e:
        warn(f&#34;Was not able to cast old columns onto new DataFrame. Are both DataFrames the same shape? Error:\n{e}&#34;)
        return None

    ### assume the old_df knows what it&#39;s doing, even if it&#39;s technically wrong.
    if dtypes is None: dtypes = dict(old_df.dtypes)
    new_df = new_df.astype(dtypes)

    if len(old_df) == 0: return new_df

    return new_df[~new_df.fillna(custom_nan).apply(tuple, 1).isin(old_df.fillna(custom_nan).apply(tuple, 1))].reset_index(drop=True)

def change_dict(d : dict, func : &#39;function&#39;):
    &#34;&#34;&#34;
    Originally was local, moving to global for multiprocessing debugging
    &#34;&#34;&#34;
    for k, v in d.items():
        if isinstance(v, dict):
            change_dict(v, func)
        else:
            d[k] = func(v)

def replace_pipes_in_dict(
        pipes : dict = None,
        func : &#39;function&#39; = str,
        debug : bool = False,
        **kw
    ) -&gt; dict:
    &#34;&#34;&#34;
    Replace the Pipes in a Pipes dict with the result of another function
    &#34;&#34;&#34;
    if pipes is None:
        from meerschaum import get_pipes
        pipes = get_pipes(debug=debug, **kw)

    result = pipes.copy()
    change_dict(result, func)
    return result

def build_where(parameters : dict):
    &#34;&#34;&#34;
    Build the WHERE clause based on the input criteria
    &#34;&#34;&#34;
    where = &#34;&#34;
    leading_and = &#34;\n    AND &#34;
    for key, value in parameters.items():
        ### search across a list (i.e. IN syntax)
        if isinstance(value, list):
            where += f&#34;{leading_and}{key} IN (&#34;
            for item in value:
                where += f&#34;&#39;{item}&#39;, &#34;
            where = where[:-2] + &#34;)&#34;
            continue

        ### search a dictionary
        elif isinstance(value, dict):
            import json
            where += (f&#34;{leading_and}CAST({key} AS TEXT) = &#39;&#34; + json.dumps(value) + &#34;&#39;&#34;)
            continue

        where += f&#34;{leading_and}{key} &#34; + (&#34;IS NULL&#34; if value is None else f&#34;= &#39;{value}&#39;&#34;)
    if len(where) &gt; 1: where = &#34;\nWHERE\n    &#34; + where[len(leading_and):]
    return where

def enforce_gevent_monkey_patch():
    &#34;&#34;&#34;
    Check if gevent monkey patching is enabled, and if not, then apply patching
    &#34;&#34;&#34;
    from meerschaum.utils.packages import attempt_import
    import socket
    gevent, gevent_socket, gevent_monkey = attempt_import(&#39;gevent&#39;, &#39;gevent.socket&#39;, &#39;gevent.monkey&#39;)
    if not socket.socket is gevent_socket.socket:
        gevent_monkey.patch_all()

def reload_plugins(debug : bool = False):
    &#34;&#34;&#34;
    Convenience method for reloading the actions package (which loads plugins)
    &#34;&#34;&#34;
    import meerschaum.actions
    from meerschaum.utils.packages import reload_package
    reload_package(meerschaum.actions, debug=debug)

def is_valid_email(email : str) -&gt; bool:
    &#34;&#34;&#34;
    Check whether a string is a valid email
    &#34;&#34;&#34;
    import re
    regex = &#39;^[a-z0-9]+[\._]?[a-z0-9]+[@]\w+[.]\w{2,3}$&#39;
    return re.search(regex, email)

def string_width(string : str) -&gt; int:
    &#34;&#34;&#34;
    Calculate the width of a string after its last newline
    &#34;&#34;&#34;
    found_newline = False
    width = 0
    for c in reversed(string):
        if c == &#39;\n&#39; and found_newline: break
        elif c == &#39;\n&#39;:
            found_newline = True
            continue
        if found_newline:
            width += 1
    return width

def _pyinstaller_traverse_dir(
        directory : str,
        ignore_patterns : list = [&#39;.pyc&#39;, &#39;dist&#39;, &#39;build&#39;, &#39;.git&#39;, &#39;.log&#39;],
        include_dotfiles : bool = False
    ) -&gt; list:
    &#34;&#34;&#34;
    Recursively traverse a directory and return a list of its contents.
    &#34;&#34;&#34;
    import os, pathlib
    paths = []
    _directory = pathlib.Path(directory)

    def _found_pattern(name : str):
        for pattern in ignore_patterns:
            if pattern.replace(&#39;/&#39;, os.path.sep) in str(name):
                return True
        return False

    for root, dirs, files in os.walk(_directory):
        _root = str(root)[len(str(_directory.parent)):]
        if _root.startswith(os.path.sep):
            _root = _root[len(os.path.sep):]
        if _root.startswith(&#39;.&#39;) and not include_dotfiles:
            continue
        ### ignore certain patterns
        if _found_pattern(_root):
            continue

        for filename in files:
            if filename.startswith(&#39;.&#39;) and not include_dotfiles:
                continue
            path = os.path.join(root, filename)
            if _found_pattern(path):
                continue

            _path = str(path)[len(str(_directory.parent)):]
            if _path.startswith(os.path.sep):
                _path = _path[len(os.path.sep):]
            _path = os.path.sep.join(_path.split(os.path.sep)[:-1])

            paths.append((path, _path))
    return paths</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="meerschaum.utils.misc.add_method_to_class"><code class="name flex">
<span>def <span class="ident">add_method_to_class</span></span>(<span>func: Callable[[Any], Any], class_def: ClassVar[dict[Any, Any]], method_name: Optional[str] = None) ‑> Callable[[Any], Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Add function <code>func</code> to class <code>class_def</code>.</p>
<p>:param func:
Function to be added as a method of the class</p>
<p>:param class_def:
Class we are modifying</p>
<p>:param method_name:
New name of the method. None will use func.<strong>name</strong> (default).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_method_to_class(
        func : Callable[[Any], Any],
        class_def : ClassVar[dict[Any, Any]],
        method_name : Optional[str] = None
    ) -&gt; Callable[[Any], Any]:
    &#34;&#34;&#34;
    Add function `func` to class `class_def`.

    :param func:
        Function to be added as a method of the class

    :param class_def:
        Class we are modifying

    :param method_name:
        New name of the method. None will use func.__name__ (default).
    &#34;&#34;&#34;
    from functools import wraps

    @wraps(func)
    def wrapper(self, *args, **kw):
        return func(*args, **kw)

    if method_name is None: method_name = func.__name__
    setattr(class_def, method_name, wrapper)
    return func</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.build_where"><code class="name flex">
<span>def <span class="ident">build_where</span></span>(<span>parameters: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the WHERE clause based on the input criteria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_where(parameters : dict):
    &#34;&#34;&#34;
    Build the WHERE clause based on the input criteria
    &#34;&#34;&#34;
    where = &#34;&#34;
    leading_and = &#34;\n    AND &#34;
    for key, value in parameters.items():
        ### search across a list (i.e. IN syntax)
        if isinstance(value, list):
            where += f&#34;{leading_and}{key} IN (&#34;
            for item in value:
                where += f&#34;&#39;{item}&#39;, &#34;
            where = where[:-2] + &#34;)&#34;
            continue

        ### search a dictionary
        elif isinstance(value, dict):
            import json
            where += (f&#34;{leading_and}CAST({key} AS TEXT) = &#39;&#34; + json.dumps(value) + &#34;&#39;&#34;)
            continue

        where += f&#34;{leading_and}{key} &#34; + (&#34;IS NULL&#34; if value is None else f&#34;= &#39;{value}&#39;&#34;)
    if len(where) &gt; 1: where = &#34;\nWHERE\n    &#34; + where[len(leading_and):]
    return where</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.change_dict"><code class="name flex">
<span>def <span class="ident">change_dict</span></span>(<span>d: dict, func: "'function'")</span>
</code></dt>
<dd>
<div class="desc"><p>Originally was local, moving to global for multiprocessing debugging</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_dict(d : dict, func : &#39;function&#39;):
    &#34;&#34;&#34;
    Originally was local, moving to global for multiprocessing debugging
    &#34;&#34;&#34;
    for k, v in d.items():
        if isinstance(v, dict):
            change_dict(v, func)
        else:
            d[k] = func(v)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.choices_docstring"><code class="name flex">
<span>def <span class="ident">choices_docstring</span></span>(<span>action: str, globs: dict = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choices_docstring(action : str, globs : dict = None):
    options_str = f&#34;\n    Options:\n        `{action} &#34;
    subactions = get_subactions(action, globs=globs)
    options_str += &#34;[&#34;
    sa_names = []
    for sa in subactions:
        sa_names.append(sa.__name__[len(f&#34;_{action}&#34;) + 1:])
    for sa_name in sorted(sa_names):
        options_str += f&#34;{sa_name}, &#34;
    options_str = options_str[:-2] + &#34;]`&#34;
    return options_str</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.choose_subaction"><code class="name flex">
<span>def <span class="ident">choose_subaction</span></span>(<span>action: list = [''], options: dict = {}, **kw) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Given a dictionary of options and the standard Meerschaum actions list,
check if choice is valid and execute chosen function, else show available
options and return False</p>
<p>action - list:
subactions (e.g. <code>show pipes</code> -&gt; ['pipes'])
options - dict:
Available options to execute
option (key) -&gt; function (value)
Functions must accept **kw keyword arguments
and return a tuple of success code and message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_subaction(
        action : list = [&#39;&#39;],
        options : dict = {},
        **kw
    ) -&gt; tuple:
    &#34;&#34;&#34;
    Given a dictionary of options and the standard Meerschaum actions list,
    check if choice is valid and execute chosen function, else show available
    options and return False

    action - list:
        subactions (e.g. `show pipes` -&gt; [&#39;pipes&#39;])
    options - dict:
        Available options to execute
        option (key) -&gt; function (value)
        Functions must accept **kw keyword arguments
        and return a tuple of success code and message
    &#34;&#34;&#34;
    from meerschaum.utils.warnings import warn, info
    import inspect
    parent_action = inspect.stack()[1][3]
    if len(action) == 0: action = [&#39;&#39;]
    choice = action[0]

    def valid_choice(_choice : str, _options : dict):
        if _choice in _options: return _choice
        if (_choice + &#39;s&#39;) in options: return _choice + &#39;s&#39;
        return None

    parsed_choice = valid_choice(choice, options)
    if parsed_choice is None:
        warn(f&#34;Cannot {parent_action} &#39;{choice}&#39;. Choose one:&#34;, stack=False)
        for option in sorted(options):
            print(f&#34;  - {parent_action} {option}&#34;)
        return (False, f&#34;Invalid choice &#39;{choice}&#39;&#34;)
    ### remove parent sub-action
    kw[&#39;action&#39;] = list(action)
    del kw[&#39;action&#39;][0]
    return options[parsed_choice](**kw)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.df_from_literal"><code class="name flex">
<span>def <span class="ident">df_from_literal</span></span>(<span>pipe: "'<a title="meerschaum.Pipe" href="../Pipe/index.html">meerschaum.Pipe</a>'" = None, literal: str = None, debug: bool = False) ‑> pd.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a literal (if nessary), and use a Pipe's column names to generate a DataFrame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def df_from_literal(
        pipe : &#39;meerschaum.Pipe&#39; = None,
        literal : str = None,
        debug : bool = False
    ) -&gt; &#39;pd.DataFrame&#39;:
    &#34;&#34;&#34;
    Parse a literal (if nessary), and use a Pipe&#39;s column names to generate a DataFrame.
    &#34;&#34;&#34;
    from meerschaum.utils.packages import import_pandas
    from meerschaum.utils.warnings import error, warn
    from meerschaum.utils.debug import dprint

    if pipe is None or literal is None:
        error(&#34;Please provide a Pipe and a literal value&#34;)
    ### this will raise an error if the columns are undefined
    dt_name, val_name = pipe.get_columns(&#39;datetime&#39;, &#39;value&#39;)

    val = literal
    if isinstance(literal, str):
        if debug: dprint(f&#34;Received literal string: &#39;{literal}&#39;&#34;)
        import ast
        try:
            val = ast.literal_eval(literal)
        except:
            warn(
                &#34;Failed to parse value from string:\n&#34; + f&#34;{literal}&#34; +
                &#34;\n\nWill cast as a string instead.&#34;\
            )
            val = literal

    ### NOTE: we do everything in UTC if possible.
    ### In dealing with timezones / Daylight Savings lies madness.
    import datetime
    now = datetime.datetime.utcnow()

    pd = import_pandas()
    return pd.DataFrame({dt_name : [now], val_name : [val]})</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.edit_file"><code class="name flex">
<span>def <span class="ident">edit_file</span></span>(<span>path: "'pathlib.Path'", default_editor: str = 'pyvim', debug: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Open a file for editing. Attempts to use the user's defined EDITOR,
otherwise uses pyvim.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_file(
        path : &#39;pathlib.Path&#39;,
        default_editor : str = &#39;pyvim&#39;,
        debug : bool = False
    ):
    &#34;&#34;&#34;
    Open a file for editing. Attempts to use the user&#39;s defined EDITOR,
    otherwise uses pyvim.
    &#34;&#34;&#34;
    import os
    from subprocess import call
    from meerschaum.utils.debug import dprint
    from meerschaum.utils.packages import run_python_package
    try:
        EDITOR = os.environ.get(&#39;EDITOR&#39;, default_editor)
        if debug: dprint(f&#34;Opening file &#39;{path}&#39; with editor &#39;{EDITOR}&#39;&#34;)
        call([EDITOR, path])
    except Exception as e: ### can&#39;t open with default editors
        if debug: dprint(e)
        if debug: dprint(&#39;Failed to open file with system editor. Falling back to pyvim...&#39;)
        run_python_package(&#39;pyvim&#39;, [path], debug=debug)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.enforce_gevent_monkey_patch"><code class="name flex">
<span>def <span class="ident">enforce_gevent_monkey_patch</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if gevent monkey patching is enabled, and if not, then apply patching</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enforce_gevent_monkey_patch():
    &#34;&#34;&#34;
    Check if gevent monkey patching is enabled, and if not, then apply patching
    &#34;&#34;&#34;
    from meerschaum.utils.packages import attempt_import
    import socket
    gevent, gevent_socket, gevent_monkey = attempt_import(&#39;gevent&#39;, &#39;gevent.socket&#39;, &#39;gevent.monkey&#39;)
    if not socket.socket is gevent_socket.socket:
        gevent_monkey.patch_all()</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.filter_unseen_df"><code class="name flex">
<span>def <span class="ident">filter_unseen_df</span></span>(<span>old_df: "'pd.DataFrame'", new_df: "'pd.DataFrame'", dtypes: dict = None, custom_nan: str = 'mrsm_NaN', debug: bool = False) ‑> pd.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Left join two DataFrames to find the newest unseen data.</p>
<p>I have scoured the web for the best way to do this.
My intuition was to join on datetime and id, but the code below accounts for values as well
without needing to define expicit columns or indices.</p>
<p>The logic below is based off this StackOverflow question, with an index reset thrown on top:
<a href="https://stackoverflow.com/questions/48647534/python-pandas-find-difference-between-two-data-frames#48647840">https://stackoverflow.com/questions/48647534/python-pandas-find-difference-between-two-data-frames#48647840</a></p>
<p>Also, NaN apparently does not equal NaN, so I am temporarily replacing instances of NaN with a
custom string, per this StackOverflow question:
<a href="https://stackoverflow.com/questions/31833635/pandas-checking-for-nan-not-working-using-isin">https://stackoverflow.com/questions/31833635/pandas-checking-for-nan-not-working-using-isin</a></p>
<p>Lastly, use the old DataFrame's columns for the new DataFrame, because order matters when checking equality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_unseen_df(
        old_df : &#39;pd.DataFrame&#39;,
        new_df : &#39;pd.DataFrame&#39;,
        dtypes : dict = None,
        custom_nan : str = &#39;mrsm_NaN&#39;,
        debug : bool = False,
    ) -&gt; &#39;pd.DataFrame&#39;:
    &#34;&#34;&#34;
    Left join two DataFrames to find the newest unseen data.

    I have scoured the web for the best way to do this.
    My intuition was to join on datetime and id, but the code below accounts for values as well
    without needing to define expicit columns or indices.

    The logic below is based off this StackOverflow question, with an index reset thrown on top:
    https://stackoverflow.com/questions/48647534/python-pandas-find-difference-between-two-data-frames#48647840

    Also, NaN apparently does not equal NaN, so I am temporarily replacing instances of NaN with a
    custom string, per this StackOverflow question:
    https://stackoverflow.com/questions/31833635/pandas-checking-for-nan-not-working-using-isin

    Lastly, use the old DataFrame&#39;s columns for the new DataFrame, because order matters when checking equality.
    &#34;&#34;&#34;
    if old_df is None: return new_df
    old_cols = list(old_df.columns)
    try:
        new_df = new_df[old_cols]
    except Exception as e:
        warn(f&#34;Was not able to cast old columns onto new DataFrame. Are both DataFrames the same shape? Error:\n{e}&#34;)
        return None

    ### assume the old_df knows what it&#39;s doing, even if it&#39;s technically wrong.
    if dtypes is None: dtypes = dict(old_df.dtypes)
    new_df = new_df.astype(dtypes)

    if len(old_df) == 0: return new_df

    return new_df[~new_df.fillna(custom_nan).apply(tuple, 1).isin(old_df.fillna(custom_nan).apply(tuple, 1))].reset_index(drop=True)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.flatten_pipes_dict"><code class="name flex">
<span>def <span class="ident">flatten_pipes_dict</span></span>(<span>pipes_dict: dict) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the standard pipes dictionary into a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten_pipes_dict(pipes_dict : dict) -&gt; list:
    &#34;&#34;&#34;
    Convert the standard pipes dictionary into a list
    &#34;&#34;&#34;
    pipes_list = []
    for ck in pipes_dict.values():
        for mk in ck.values():
            pipes_list += list(mk.values())
    return pipes_list</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.generate_password"><code class="name flex">
<span>def <span class="ident">generate_password</span></span>(<span>length: int = 12)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a secure password of given length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_password(
        length : int = 12
    ):
    &#34;&#34;&#34;
    Generate a secure password of given length.
    &#34;&#34;&#34;
    import secrets, string
    return &#39;&#39;.join((secrets.choice(string.ascii_letters) for i in range(length)))</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.get_options_functions"><code class="name flex">
<span>def <span class="ident">get_options_functions</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get options functions from parent module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_options_functions():
    &#34;&#34;&#34;
    Get options functions from parent module
    &#34;&#34;&#34;
    import inspect
    parent_globals = inspect.stack()[1][0].f_globals
    parent_package = parent_globals[&#39;__name__&#39;]
    print(parent_package)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.get_subactions"><code class="name flex">
<span>def <span class="ident">get_subactions</span></span>(<span>action: str, globs: dict = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of function pointers to all subactions for a given action</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subactions(action : str, globs : dict = None) -&gt; list:
    &#34;&#34;&#34;
    Return a list of function pointers to all subactions for a given action
    &#34;&#34;&#34;
    if globs is None:
        import importlib
        module = importlib.import_module(f&#39;meerschaum.actions.{action}&#39;)
        globs = vars(module)
    subactions = []
    for item in globs:
        if f&#39;_{action}&#39; in item:
            subactions.append(globs[item])
    return subactions</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.is_int"><code class="name flex">
<span>def <span class="ident">is_int</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if string is an int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_int(s):
    &#34;&#34;&#34;
    Check if string is an int
    &#34;&#34;&#34;
    try:
        float(s)
    except ValueError:
        return False
    else:
        return float(s).is_integer()</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.is_pipe_registered"><code class="name flex">
<span>def <span class="ident">is_pipe_registered</span></span>(<span>pipe: "'Pipe or MetaPipe'", pipes: dict, debug: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a Pipe or MetaPipe is inside the pipes dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_pipe_registered(
        pipe : &#39;Pipe or MetaPipe&#39;,
        pipes : dict,
        debug : bool = False
    ):
    &#34;&#34;&#34;
    Check if a Pipe or MetaPipe is inside the pipes dictionary.
    &#34;&#34;&#34;
    from meerschaum.utils.debug import dprint
    ck, mk, lk = pipe.connector_keys, pipe.metric_key, pipe.location_key
    if debug:
        dprint(f&#39;{ck}, {mk}, {lk}&#39;)
        dprint(f&#39;{pipe}, {pipes}&#39;)
    return ck in pipes and mk in pipes[ck] and lk in pipes[ck][mk]</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.is_valid_email"><code class="name flex">
<span>def <span class="ident">is_valid_email</span></span>(<span>email: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether a string is a valid email</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_email(email : str) -&gt; bool:
    &#34;&#34;&#34;
    Check whether a string is a valid email
    &#34;&#34;&#34;
    import re
    regex = &#39;^[a-z0-9]+[\._]?[a-z0-9]+[@]\w+[.]\w{2,3}$&#39;
    return re.search(regex, email)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.parse_config_substitution"><code class="name flex">
<span>def <span class="ident">parse_config_substitution</span></span>(<span>value: str, leading_key: str = 'MRSM', begin_key: str = '{', end_key: str = '}', delimeter: str = ':')</span>
</code></dt>
<dd>
<div class="desc"><p>Parse Meerschaum substitution syntax
E.g. MRSM{value1:value2} =&gt; ['value1', 'value2']
NOTE: Not currently used. See <code><a title="meerschaum.utils.misc.search_and_substitute_config" href="#meerschaum.utils.misc.search_and_substitute_config">search_and_substitute_config()</a></code> below</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_config_substitution(
        value : str,
        leading_key : str = &#39;MRSM&#39;,
        begin_key : str = &#39;{&#39;,
        end_key : str = &#39;}&#39;,
        delimeter : str = &#39;:&#39;
    ):
    &#34;&#34;&#34;
    Parse Meerschaum substitution syntax
    E.g. MRSM{value1:value2} =&gt; [&#39;value1&#39;, &#39;value2&#39;]
    NOTE: Not currently used. See `search_and_substitute_config` below
    &#34;&#34;&#34;
    if not value.beginswith(leading_key):
        return value

    return leading_key[len(leading_key):][len():-1].split(delimeter)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.parse_df_datetimes"><code class="name flex">
<span>def <span class="ident">parse_df_datetimes</span></span>(<span>df: "'pd.DataFrame'", debug: bool = False) ‑> pd.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a pandas DataFrame for datetime columns and cast as datetimes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_df_datetimes(
        df : &#39;pd.DataFrame&#39;,
        debug : bool = False
    ) -&gt; &#39;pd.DataFrame&#39;:
    &#34;&#34;&#34;
    Parse a pandas DataFrame for datetime columns and cast as datetimes
    &#34;&#34;&#34;
    from meerschaum.utils.packages import import_pandas
    ### import pandas (or pandas replacement)
    from meerschaum.utils.debug import dprint
    pd = import_pandas()

    ### if df is a dict, build DataFrame
    if not isinstance(df, pd.DataFrame):
        if debug: dprint(f&#34;df is not a DataFrame. Casting to DataFrame...&#34;)
        df = pd.DataFrame(df)

    ### skip parsing if DataFrame is empty
    if len(df) == 0:
        if debug: dprint(f&#34;df is empty. Returning original DataFrame without casting datetime columns...&#34;)
        return df

    ### apply regex to columns to determine which are ISO datetimes
    iso_dt_regex = r&#39;\d{4}-\d{2}-\d{2}.\d{2}\:\d{2}\:\d{2}&#39;
    dt_mask = df.astype(str).apply(
        lambda s : s.str.match(iso_dt_regex).all()
    )

    ### list of datetime column names
    datetimes = list(df.loc[:, dt_mask])
    if debug: dprint(&#34;Converting columns to datetimes: &#34; + str(datetimes))

    ### apply to_datetime
    df[datetimes] = df[datetimes].apply(pd.to_datetime)

    ### strip timezone information
    for dt in datetimes:
        df[dt] = df[dt].dt.tz_localize(None)

    return df</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.pg_capital"><code class="name flex">
<span>def <span class="ident">pg_capital</span></span>(<span>s: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>If string contains a capital letter, wrap it in double quotes</p>
<p>returns: string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pg_capital(s : str) -&gt; str:
    &#34;&#34;&#34;
    If string contains a capital letter, wrap it in double quotes

    returns: string
    &#34;&#34;&#34;
    if &#39;&#34;&#39; in s: return s
    needs_quotes = False
    for c in str(s):
        if c.isupper():
            needs_quotes = True
            break
    if needs_quotes:
        return &#39;&#34;&#39; + s + &#39;&#34;&#39;
    return s</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.print_options"><code class="name flex">
<span>def <span class="ident">print_options</span></span>(<span>options: dict = {}, nopretty: bool = False, name: str = 'options', header: str = None, **kw) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Show available options from an iterable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_options(
        options : dict = {},
        nopretty : bool = False,
        name : str = &#39;options&#39;,
        header : str = None,
        **kw
    ) -&gt; None:
    &#34;&#34;&#34;
    Show available options from an iterable
    &#34;&#34;&#34;
    from meerschaum.utils.formatting import make_header
    _options = []
    for o in options: _options.append(str(o))

    print()
    if not nopretty:
        if header is None: _header = f&#34;Available {name}:&#34;
        else: _header = header
        print(make_header(_header))
        ### calculate underline length
        #  underline_len = len(_header)
        #  for o in _options:
            #  if len(str(o)) + 4 &gt; underline_len:
                #  underline_len = len(str(o)) + 4
        #  ### print underline
        #  for i in range(underline_len): print(&#39;-&#39;, end=&#34;&#34;)
        #  print(&#34;\n&#34;, end=&#34;&#34;)
    ### print actions
    for option in sorted(_options):
        if not nopretty: print(&#34;  - &#34;, end=&#34;&#34;)
        print(option)

    print()</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.reload_plugins"><code class="name flex">
<span>def <span class="ident">reload_plugins</span></span>(<span>debug: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method for reloading the actions package (which loads plugins)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload_plugins(debug : bool = False):
    &#34;&#34;&#34;
    Convenience method for reloading the actions package (which loads plugins)
    &#34;&#34;&#34;
    import meerschaum.actions
    from meerschaum.utils.packages import reload_package
    reload_package(meerschaum.actions, debug=debug)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.replace_pipes_in_dict"><code class="name flex">
<span>def <span class="ident">replace_pipes_in_dict</span></span>(<span>pipes: dict = None, func: "'function'" = builtins.str, debug: bool = False, **kw) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the Pipes in a Pipes dict with the result of another function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_pipes_in_dict(
        pipes : dict = None,
        func : &#39;function&#39; = str,
        debug : bool = False,
        **kw
    ) -&gt; dict:
    &#34;&#34;&#34;
    Replace the Pipes in a Pipes dict with the result of another function
    &#34;&#34;&#34;
    if pipes is None:
        from meerschaum import get_pipes
        pipes = get_pipes(debug=debug, **kw)

    result = pipes.copy()
    change_dict(result, func)
    return result</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.retry_connect"><code class="name flex">
<span>async def <span class="ident">retry_connect</span></span>(<span>connector: Union[<a title="meerschaum.connectors.sql.SQLConnector" href="../connectors/sql/SQLConnector.html">meerschaum.connectors.sql.SQLConnector</a>, databases.Database, None] = None, max_retries: int = 40, retry_wait: int = 3, debug: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep trying to connect to the database.
Use wait_for_connection for non-async</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def retry_connect(
        connector : Union[meerschaum.connectors.sql.SQLConnector, databases.Database, None] = None,
        max_retries : int = 40,
        retry_wait : int = 3,
        debug : bool = False,
    ):
    &#34;&#34;&#34;
    Keep trying to connect to the database.
    Use wait_for_connection for non-async
    &#34;&#34;&#34;
    from meerschaum.utils.warnings import warn
    from meerschaum.utils.debug import dprint
    from meerschaum import get_connector
    from meerschaum.connectors.sql import SQLConnector
    import time

    ### get default connector if None is provided
    if connector is None:
        connector = get_connector()

    database = connector
    if isinstance(connector, SQLConnector):
        database = connector.db


    retries = 0
    while retries &lt; max_retries:
        if debug:
            dprint(f&#34;Trying to connect to the database&#34;)
            dprint(f&#34;Attempt ({retries + 1} / {max_retries})&#34;)
        try:
            await database.connect()

        except Exception as e:
            dprint(f&#34;Connection failed. Retrying in {retry_wait} seconds...&#34;)
            time.sleep(retry_wait)
            retries += 1
        else:
            if debug: dprint(&#34;Connection established!&#34;)
            break</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.round_time"><code class="name flex">
<span>def <span class="ident">round_time</span></span>(<span>dt: "'datetime.datetime'" = None, date_delta: "'datetime.timedelta'" = None, to: "'str'" = 'down') ‑> datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Round a datetime object to a multiple of a timedelta
dt : datetime.datetime object, default now.
dateDelta : timedelta object, we round to a multiple of this, default 1 minute.
from:
<a href="http://stackoverflow.com/questions/3463930/how-to-round-the-minute-of-a-datetime-object-python">http://stackoverflow.com/questions/3463930/how-to-round-the-minute-of-a-datetime-object-python</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_time(
        dt : &#39;datetime.datetime&#39; = None,
        date_delta : &#39;datetime.timedelta&#39; = None,
        to : &#39;str&#39; = &#39;down&#39;
    ) -&gt; &#39;datetime.datetime&#39;:
    &#34;&#34;&#34;
    Round a datetime object to a multiple of a timedelta
    dt : datetime.datetime object, default now.
    dateDelta : timedelta object, we round to a multiple of this, default 1 minute.
    from:  http://stackoverflow.com/questions/3463930/how-to-round-the-minute-of-a-datetime-object-python
    &#34;&#34;&#34;
    import datetime
    if date_delta is None: date_delta = datetime.timedelta(minutes=1)
    round_to = date_delta.total_seconds()
    if dt is None:
        dt = datetime.datetime.utcnow()
    seconds = (dt.replace(tzinfo=None) - dt.min.replace(tzinfo=None)).seconds

    if seconds % round_to == 0 and dt.microsecond == 0:
        rounding = (seconds + round_to / 2) // round_to * round_to
    else:
        if to == &#39;up&#39;:
            # // is a floor division, not a comment on following line (like in javascript):
            rounding = (seconds + dt.microsecond/1000000 + round_to) // round_to * round_to
        elif to == &#39;down&#39;:
            rounding = seconds // round_to * round_to
        else:
            rounding = (seconds + round_to / 2) // round_to * round_to

    return dt + datetime.timedelta(0, rounding - seconds, - dt.microsecond)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.search_and_substitute_config"><code class="name flex">
<span>def <span class="ident">search_and_substitute_config</span></span>(<span>config: dict, leading_key: str = 'MRSM', delimiter: str = ':', begin_key: str = '{', end_key: str = '}') ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Search the config for Meerschaum substitution syntax and substite with value of keys</p>
<h2 id="example">Example</h2>
<p>MRSM{meerschaum:connectors:main:host} =&gt; cf['meerschaum']['connectors']['main']['host']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_and_substitute_config(
        config : dict,
        leading_key : str = &#34;MRSM&#34;,
        delimiter : str = &#34;:&#34;,
        begin_key : str = &#34;{&#34;,
        end_key : str = &#34;}&#34;
    ) -&gt; dict:
    &#34;&#34;&#34;
    Search the config for Meerschaum substitution syntax and substite with value of keys

    Example:
        MRSM{meerschaum:connectors:main:host} =&gt; cf[&#39;meerschaum&#39;][&#39;connectors&#39;][&#39;main&#39;][&#39;host&#39;]
    &#34;&#34;&#34;
    try:
        import yaml
    except ImportError:
        return config
    needle = leading_key
    haystack = yaml.dump(config)
    mod_haystack = list(str(haystack))
    buff = str(needle)
    max_index = len(haystack) - len(buff)

    patterns = dict()

    begin, end, floor = 0, 0, 0
    while needle in haystack[floor:]:
        ### extract the keys
        hs = haystack[floor:]

        ### the first character of the keys
        ### MRSM{value1:value2}
        ###      ^
        begin = hs.find(needle) + len(needle) + len(begin_key)

        ### number of characters to end of keys
        ### (really it&#39;s the index of the beginning of the end_key relative to the beginning
        ###     but the math works out)
        ### MRSM{value1}
        ###      ^     ^  =&gt; 6
        length = hs[begin:].find(end_key)

        ### index of the end_key (end of `length` characters)
        end = begin + length

        ### advance the floor to find the next leading key
        floor += end + len(end_key)
        keys = hs[begin:end].split(delimiter)

        ### follow the pointers to the value
        c = config
        for k in keys:
            try:
                c = c[k]
            except KeyError:
                from meerschaum.utils.warnings import warn
                warn(f&#34;Invalid keys in config: {keys}&#34;)
        value = c

        ### pattern to search and replace
        pattern = leading_key + begin_key + delimiter.join(keys) + end_key
        ### store patterns and values
        patterns[pattern] = value

    ### replace the patterns with the values
    for pattern, value in patterns.items():
        haystack = haystack.replace(pattern, str(value))

    ### parse back into dict
    return yaml.safe_load(haystack)</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.sorted_dict"><code class="name flex">
<span>def <span class="ident">sorted_dict</span></span>(<span>d: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Sort a dictionary's keys and values and return a new dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sorted_dict(d : dict) -&gt; dict:
    &#34;&#34;&#34;
    Sort a dictionary&#39;s keys and values and return a new dictionary
    &#34;&#34;&#34;
    try:
        return {key: value for key, value in sorted(d.items(), key=lambda item: item[1])}
    except:
        return d</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.sql_item_name"><code class="name flex">
<span>def <span class="ident">sql_item_name</span></span>(<span>s: str, flavor: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Parse SQL items depending on the flavor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sql_item_name(s : str, flavor : str) -&gt; str:
    &#34;&#34;&#34;
    Parse SQL items depending on the flavor
    &#34;&#34;&#34;
    if flavor in {&#39;timescaledb&#39;, &#39;postgresql&#39;}: s = pg_capital(s)
    elif flavor == &#39;sqlite&#39;: s = &#34;\&#34;&#34; + s + &#34;\&#34;&#34;
    return s</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.string_to_dict"><code class="name flex">
<span>def <span class="ident">string_to_dict</span></span>(<span>params_string: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a string into a dictionary</p>
<p>If the string begins with '{', parse as JSON. Else use simple parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_to_dict(
        params_string : str
    ) -&gt; dict:
    &#34;&#34;&#34;
    Parse a string into a dictionary

    If the string begins with &#39;{&#39;, parse as JSON. Else use simple parsing

    &#34;&#34;&#34;
    if params_string == &#34;&#34;: return dict()

    if str(params_string)[0] == &#39;{&#39;:
        import json
        return json.loads(params_string)

    import ast
    params_dict = dict()
    for param in params_string.split(&#34;,&#34;):
        values = param.split(&#34;:&#34;)
        try:
            key = ast.literal_eval(values[0])
        except:
            key = str(values[0])

        for value in values[1:]:
            try:
                params_dict[key] = ast.literal_eval(value)
            except:
                params_dict[key] = str(value)
    return params_dict</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.string_width"><code class="name flex">
<span>def <span class="ident">string_width</span></span>(<span>string: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the width of a string after its last newline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_width(string : str) -&gt; int:
    &#34;&#34;&#34;
    Calculate the width of a string after its last newline
    &#34;&#34;&#34;
    found_newline = False
    width = 0
    for c in reversed(string):
        if c == &#39;\n&#39; and found_newline: break
        elif c == &#39;\n&#39;:
            found_newline = True
            continue
        if found_newline:
            width += 1
    return width</code></pre>
</details>
</dd>
<dt id="meerschaum.utils.misc.wait_for_connection"><code class="name flex">
<span>def <span class="ident">wait_for_connection</span></span>(<span>**kw)</span>
</code></dt>
<dd>
<div class="desc"><p>Block until a connection to the SQL database is made.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_connection(**kw):
    &#34;&#34;&#34;
    Block until a connection to the SQL database is made.
    &#34;&#34;&#34;
    import asyncio
    asyncio.run(retry_connect(**kw))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="meerschaum.utils" href="index.html">meerschaum.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="meerschaum.utils.misc.add_method_to_class" href="#meerschaum.utils.misc.add_method_to_class">add_method_to_class</a></code></li>
<li><code><a title="meerschaum.utils.misc.build_where" href="#meerschaum.utils.misc.build_where">build_where</a></code></li>
<li><code><a title="meerschaum.utils.misc.change_dict" href="#meerschaum.utils.misc.change_dict">change_dict</a></code></li>
<li><code><a title="meerschaum.utils.misc.choices_docstring" href="#meerschaum.utils.misc.choices_docstring">choices_docstring</a></code></li>
<li><code><a title="meerschaum.utils.misc.choose_subaction" href="#meerschaum.utils.misc.choose_subaction">choose_subaction</a></code></li>
<li><code><a title="meerschaum.utils.misc.df_from_literal" href="#meerschaum.utils.misc.df_from_literal">df_from_literal</a></code></li>
<li><code><a title="meerschaum.utils.misc.edit_file" href="#meerschaum.utils.misc.edit_file">edit_file</a></code></li>
<li><code><a title="meerschaum.utils.misc.enforce_gevent_monkey_patch" href="#meerschaum.utils.misc.enforce_gevent_monkey_patch">enforce_gevent_monkey_patch</a></code></li>
<li><code><a title="meerschaum.utils.misc.filter_unseen_df" href="#meerschaum.utils.misc.filter_unseen_df">filter_unseen_df</a></code></li>
<li><code><a title="meerschaum.utils.misc.flatten_pipes_dict" href="#meerschaum.utils.misc.flatten_pipes_dict">flatten_pipes_dict</a></code></li>
<li><code><a title="meerschaum.utils.misc.generate_password" href="#meerschaum.utils.misc.generate_password">generate_password</a></code></li>
<li><code><a title="meerschaum.utils.misc.get_options_functions" href="#meerschaum.utils.misc.get_options_functions">get_options_functions</a></code></li>
<li><code><a title="meerschaum.utils.misc.get_subactions" href="#meerschaum.utils.misc.get_subactions">get_subactions</a></code></li>
<li><code><a title="meerschaum.utils.misc.is_int" href="#meerschaum.utils.misc.is_int">is_int</a></code></li>
<li><code><a title="meerschaum.utils.misc.is_pipe_registered" href="#meerschaum.utils.misc.is_pipe_registered">is_pipe_registered</a></code></li>
<li><code><a title="meerschaum.utils.misc.is_valid_email" href="#meerschaum.utils.misc.is_valid_email">is_valid_email</a></code></li>
<li><code><a title="meerschaum.utils.misc.parse_config_substitution" href="#meerschaum.utils.misc.parse_config_substitution">parse_config_substitution</a></code></li>
<li><code><a title="meerschaum.utils.misc.parse_df_datetimes" href="#meerschaum.utils.misc.parse_df_datetimes">parse_df_datetimes</a></code></li>
<li><code><a title="meerschaum.utils.misc.pg_capital" href="#meerschaum.utils.misc.pg_capital">pg_capital</a></code></li>
<li><code><a title="meerschaum.utils.misc.print_options" href="#meerschaum.utils.misc.print_options">print_options</a></code></li>
<li><code><a title="meerschaum.utils.misc.reload_plugins" href="#meerschaum.utils.misc.reload_plugins">reload_plugins</a></code></li>
<li><code><a title="meerschaum.utils.misc.replace_pipes_in_dict" href="#meerschaum.utils.misc.replace_pipes_in_dict">replace_pipes_in_dict</a></code></li>
<li><code><a title="meerschaum.utils.misc.retry_connect" href="#meerschaum.utils.misc.retry_connect">retry_connect</a></code></li>
<li><code><a title="meerschaum.utils.misc.round_time" href="#meerschaum.utils.misc.round_time">round_time</a></code></li>
<li><code><a title="meerschaum.utils.misc.search_and_substitute_config" href="#meerschaum.utils.misc.search_and_substitute_config">search_and_substitute_config</a></code></li>
<li><code><a title="meerschaum.utils.misc.sorted_dict" href="#meerschaum.utils.misc.sorted_dict">sorted_dict</a></code></li>
<li><code><a title="meerschaum.utils.misc.sql_item_name" href="#meerschaum.utils.misc.sql_item_name">sql_item_name</a></code></li>
<li><code><a title="meerschaum.utils.misc.string_to_dict" href="#meerschaum.utils.misc.string_to_dict">string_to_dict</a></code></li>
<li><code><a title="meerschaum.utils.misc.string_width" href="#meerschaum.utils.misc.string_width">string_width</a></code></li>
<li><code><a title="meerschaum.utils.misc.wait_for_connection" href="#meerschaum.utils.misc.wait_for_connection">wait_for_connection</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>